<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>multikey -- A Lua Table Indexed by Multiple Keys</title>
	<link rel="stylesheet" type="text/css" href="default.css" />
<link rel="stylesheet" type="text/css" href="highlight.css" /><script type="text/javascript" src="highlight.pack.js"></script><script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script></head>
<body>

<p><img src="multikey.png" alt="multikey Logo" /></p>

<h1>multikey -- A Lua Table Indexed by Multiple Keys</h1><div class="toc"><a href="#Introduction" title="Introduction">Introduction</a> · <a href="#Getting_Started" title="Getting Started">Getting Started</a> · <a href="#Reference" title="Reference">Reference</a> · <a href="#multikey.memoize" title="multikey.memoize">multikey.memoize</a> · <a href="#Download" title="Download">Download</a> · <a href="#Installation" title="Installation">Installation</a> · <a href="#Contact" title="Contact">Contact</a> · <a href="#License" title="License">License</a></div>

<h2><a name="Introduction" id="Introduction"></a>Introduction</h2>

<p>A Lua table maps single (non-nil) keys to single values. While it is
easy to wrap multiple values in an array to store it in the table,
using multiple keys as indices is not as simple because every array
used to group multiple keys would map to a different value.
This small module provides functions to store/retrieve values indexed
by a key-tuple in a table.</p>


<h2><a name="Getting_Started" id="Getting_Started"></a>Getting Started</h2>

<p>Load the <code>multikey</code> module via <code>require</code> (you may want to assign
a short variable name or add local aliases to the <code>put</code> and <code>get</code>
functions).</p>

<pre><code>local mk = require( "multikey" )
local get, put = mk.get, mk.put
</code></pre>

<p>You can use the module's functions on any table, previous values
should be completely unaffected by this module (with the exception of
the <code>clear</code> function). <code>get</code>, <code>put</code>, and <code>putv</code> are vararg functions
that work with any number of keys, including zero. You can also use
<code>nil</code> and <code>NaN</code> as keys.</p>

<pre><code>local t = { 1 }
put( t, 1,2,     "value1" )
put( t, 1,nil,3, "value2" )
put( t, 1,2,3,   "value3" )
put( t, "value4" )
print( get( t, 1,2 ) )        --&gt;  value1
print( get( t, 1,nil,3 ) )    --&gt;  value2
print( get( t, 1,2,3 ) )      --&gt;  value3
print( get( t, 1 ) )          --&gt;  nil
print( get( t ) )             --&gt;  value4
print( t[ 1 ] )               --&gt;  1
</code></pre>

<p><code>put</code> is convenient when you already know the keys you want to use. If
you get the keys via a vararg list, the <code>putv</code> function is more
useful, because it takes the value to assign as second parameter
before the keys. Assigning <code>nil</code> will remove a previous value stored
under the same keys from the table.</p>

<pre><code>put( t, 1,2,3,  nil )
print( get( t, 1,2,3 ) )      --&gt;  nil
</code></pre>

<p>For <code>pairs</code>- and <code>ipairs</code>-like iteration there are the <code>tuples</code> and
<code>ituples</code> functions. Since <code>nil</code>s are valid keys, the <code>tuple</code> iterator
produces an extra boolean as first generated value to avoid stopping
the for loop prematurely.</p>

<pre><code>for _,a,b,c,d in mk.tuples( t ) do
  print( a, b, c, d )
end
</code></pre>

<p>The <code>clear</code> function removes <em>all</em> values from the table.
In case you like an object-oriented syntax, the <code>new</code> function will
return a table with a metatable set, so that you can use the module
functions as methods.</p>

<pre><code>local t2 = mk.new()           --   mk() would have the same effect
t2:put( 1,2,  "value" )
print( t2:get( 1,2 ) )        --&gt;  value
t2:clear()
print( t2:get( 1,2 ) )        --&gt;  nil
</code></pre>

<p>That's basically it.</p>


<h2><a name="Reference" id="Reference"></a>Reference</h2>

<p>The following reference assumes that the result of <code>require</code>'ing the
module is stored in a local variable <code>mk</code>.</p>

<h4>mk.new() or mk()</h4>

<pre><code class="no-highlight">mk.new() ==&gt; object

mk() ==&gt; object
</code></pre>

<p>Constructor for a multikey object that has a suitable metatable to
allow calling all module functions as methods of this object. It also
sets <code>__ipairs</code> and <code>__pairs</code> to the iterator functions below.</p>

<h4>mk.get() or obj:get()</h4>

<pre><code class="no-highlight">mk.get( table, ... ) ==&gt; any  -- the value
    ... : any*   -- the keys to use for indexing
</code></pre>

<p>The <code>get</code> function retrieves a value from a multikey table. The keys
(zero or more) are given as separate arguments to this function and
can be any Lua value (including <code>nil</code> and <code>NaN</code>).</p>

<h4>mk.put or obj:put()</h4>

<pre><code class="no-highlight">mk.put( table, ... ) ==&gt; table  -- returns the multikey table
    ... : any*, any   -- the keys followed by a single value
</code></pre>

<p>This function puts a value into the multikey table indexed by any
number and type of keys. The last element of the vararg list is the
value to be stored, all arguments before that are keys.</p>

<h4>mk.putv() or obj:putv()</h4>

<pre><code class="no-highlight">mk.putv( table, val, ... ) ==&gt; table  -- returns multikey table
    val : any    -- the value to store
    ... : any*   -- the keys to use for indexing
</code></pre>

<p>This function works similar to the <code>put</code> function above, but the value
to be stored comes before the keys in the argument list. This is
useful if you get the keys via a vararg list yourself.</p>

<h4>mk.clear() or obj:clear()</h4>

<pre><code class="no-highlight">mk.clear( table ) ==&gt; table  -- returns the empty multikey table
</code></pre>

<p>Sets any key/value in the given table to <code>nil</code>.</p>

<h4>mk.tuples() or obj:tuples()</h4>

<pre><code class="no-highlight">mk.tuples( table, ... ) ==&gt; function  -- for loop iterator
    ... : any*   -- prefix keys where to start iteration from
</code></pre>

<p>The <code>tuples</code> function returns a for loop iterator that iterates over
all keys and values similar to the <code>pairs</code> iterator. Since <code>nil</code>s are
valid keys in multikey tables, the first value the iterator returns is
a non-<code>nil</code> dummy value. You can specify a set of keys to start the
iteration from as arguments to this function.</p>

<h4>mk.ituples() or obj:ituples()</h4>

<pre><code class="no-highlight">mk.ituples( table, ... ) ==&gt; function  -- for loop iterator
    ... : any*   -- prefix keys where to start iteration from
</code></pre>

<p>The <code>ituples</code> function returns a for loop iterator that iterates over
all integer keys starting from 1 (similar to <code>ipairs</code>). It does not
use a dummy value as the <code>tuples</code> function above.</p>


<h3>How It Works</h3>

<p>This module exploits the fact that a Lua table can be used as a unique
key in another table and as a container for other key-value mappings.
Here is what a multikey object looks like after <code>t:put( "a", "a" )</code>,
<code>t:put( "a","b", "a,b" )</code>, and <code>t:put( "a","c", "a,c" )</code>:</p>

<pre><code>mt = {
  [ &lt;private key&gt; ] = {
    a = {     -- this table is t1
      b = {}, -- this table is t2
      c = {}  -- this table is t3
    }
  },
  [ t1 ] = "a",   -- table t1 from above is used as a key
  [ t2 ] = "a,b", -- table t2 from above is used as a key
  [ t3 ] = "a,c"  -- table t3 from above is used as a key
}
</code></pre>

<p>This is the same thing but as a pretty picture:</p>

<p><img src="internal.gif" alt="Internal Structure" /></p>


<h2><a name="multikey.memoize" id="multikey.memoize"></a>multikey.memoize</h2>

<p>One popular use of normal Lua tables is to <a href="http://lua-users.org/wiki/FuncTables">memoize</a> functions,
i.e.  cache the result of a function call indexed by the argument of
the call and reuse the result if the same arguments are used again.
Normal tables only support one key and therefore single argument
functions.  Using the <code>multikey</code> module support for any number of
arguments is possible. The <code>multikey.memoize</code> submodule contains such
an implementation.</p>


<p>Basic usage is:</p>

<pre><code>$ cat &gt; test.lua
local memoize = require( "multikey.memoize" )
local function f( a, b, c, d )
  print( "f called:", a, b, c, d )
  return a+b, c+d
end
local f2 = memoize( f )
print( f2( 1, 2, 3, 4 ) )
print( f2( 1, 2, 3, 4 ) )
print( f2( 1, 3, 3, 4 ) )
print( f2( 1, 3, 3, 4 ) )
print( f2( 1, 2, 3, 4 ) )
^D
</code></pre>

<p>The result is:</p>

<pre><code class="no-highlight">$ lua test.lua
f called:       1       2       3       4
3       7
3       7
f called:       1       3       3       4
4       7
4       7
3       7
</code></pre>

<p>Beware that this memoization is a lot more expensive than the single
argument version, so profile first!</p>


<h2><a name="Download" id="Download"></a>Download</h2>

<p>The source code (with documentation and test scripts) is available on
<a href="https://github.com/siffiejoe/lua-multikey/">github</a>.</p>



<h2><a name="Installation" id="Installation"></a>Installation</h2>

<p>There are two ways to install this module, either using luarocks (if
this module already is in the <a href="http://luarocks.org/repositories/rocks/" title="Main Repository">main luarocks repository</a>) or
manually.</p>

<p>Using luarocks, simply type:</p>

<pre><code>luarocks install multikey
</code></pre>

<p>To install the module manually just drop <code>multikey.lua</code> and the
<code>multikey</code>-directory somewhere into your Lua <code>package.path</code>.</p>



<h2><a name="Contact" id="Contact"></a>Contact</h2>

<p>Philipp Janda, siffiejoe(a)gmx.net</p>

<p>Comments and feedback are always welcome.</p>


<h2><a name="License" id="License"></a>License</h2>

<p><code>multikey</code> is <em>copyrighted free software</em> distributed under the MIT
license (the same license as Lua 5.1). The full license text follows:</p>

<pre><code class="no-highlight">multikey (c) 2011,2014 Philipp Janda

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHOR OR COPYRIGHT HOLDER BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</code></pre>



</body></html>
